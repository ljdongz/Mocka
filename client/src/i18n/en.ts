const en = {
  locale: 'en-US',

  common: {
    cancel: 'Cancel',
    save: 'Save',
    create: 'Create',
    delete: 'Delete',
    none: 'None',
  },

  settings: {
    title: 'Settings',
    theme: 'Theme',
    dark: 'Dark',
    light: 'Light',
    language: 'Language',
    mockServerPort: 'Mock Server Port',
    portHelp: 'Changing the port will restart the mock server.',
    defaultResponseDelay: 'Default Response Delay (s)',
    historyToast: 'History Toast Notifications',
    historyToastDesc: 'Show toast when a request is received.',
  },

  sidebar: {
    collections: 'Collections',
    history: 'History',
    newEndpoint: 'New Endpoint',
    newCollection: 'New Collection',
    uncollected: 'Uncollected',
    guide: 'Guide',
    environments: 'Environments',
    importExport: 'Import / Export',
    settings: 'Settings',
    addEndpoint: 'Add Endpoint',
    rename: 'Rename',
  },

  editor: {
    selectEndpoint: 'Select an endpoint to edit, or create a new one.',
    clickToChangeMethod: 'Click to change method',
    clickToEditPath: 'Click to edit path',
    alias: 'Alias',
    enterAlias: 'Enter alias...',
    params: 'Params',
    headers: 'Headers',
    body: 'Body',
    response: 'Response',
  },

  endpointItem: {
    editAlias: 'Edit Alias',
    moveToCollection: 'Move to Collection',
    deleteEndpoint: 'Delete Endpoint',
    uncollected: 'Uncollected',
  },

  newEndpoint: {
    title: 'New Endpoint',
    httpMethod: 'HTTP Method',
    aliasOptional: 'Alias (optional)',
    aliasPlaceholder: 'e.g. Get Users, Login',
    endpointPath: 'Endpoint Path',
    collectionOptional: 'Collection (optional)',
    failedToCreate: 'Failed to create endpoint',
  },

  newCollection: {
    title: 'New Collection',
    collectionName: 'Collection Name',
    placeholder: 'My Collection',
    failedToCreate: 'Failed to create collection',
  },

  importExport: {
    title: 'Import / Export',
    export: 'Export',
    import: 'Import',
    exportAll: 'Export all endpoints & collections',
    exportSelected: 'Export selected collections',
    noCollections: 'No collections available.',
    countEndpoints: '{0} endpoints',
    downloadJson: 'Download JSON',
    exporting: 'Exporting...',
    selectJsonFile: 'Select JSON file',
    duplicateHandling: 'Duplicate handling',
    skip: 'Skip',
    skipDesc: 'Keep existing, ignore duplicates',
    overwrite: 'Overwrite',
    overwriteDesc: 'Replace existing with imported data',
    merge: 'Merge',
    mergeDesc: 'Keep existing, add new response variants',
    importing: 'Importing...',
    exportFailed: 'Export failed:',
    importFailed: 'Import failed:',
    invalidFormat: 'Invalid file format. Please select a valid Mocka export file.',
    importComplete: 'Import complete:',
    countCreated: '{0} created',
    countSkipped: '{0} skipped',
    countOverwritten: '{0} overwritten',
    countMerged: '{0} merged',
    countCollectionsCreated: '{0} collections created',
    countCollectionsSkipped: '{0} collections skipped',
    errors: 'Errors:',
  },

  environment: {
    title: 'Environments',
    createToStart: 'Create an environment to get started.',
    namePlaceholder: 'Name...',
    newEnvironment: 'New Environment',
    active: 'Active',
    setActive: 'Set Active',
    deleteEnvironment: 'Delete environment',
    variables: 'Variables',
    addVariable: 'Add Variable',
    key: 'Key',
    value: 'Value',
    noVariables: 'No variables defined.',
    noVariablesHint: 'Use {0} in response bodies to reference them.',
    variableUsageHint: 'Use {0} in response bodies and headers. Environment variables are resolved before template helpers and dynamic variables.',
  },

  history: {
    title: 'Request History',
    serverRunning: 'Server Running',
    serverStopped: 'Server Stopped',
    clearAll: 'Clear All',
    searchPlaceholder: 'Search Requests...',
    allMethods: 'All Methods',
    time: 'Time',
    method: 'Method',
    path: 'Path',
    status: 'Status',
    noRecords: 'No requests recorded yet.',
  },

  historyDetail: {
    responseBody: 'Response Body',
    requestHeaders: 'Request Headers',
    requestBody: 'Request Body',
  },

  response: {
    title: 'Mock Response',
    description: 'Define the mock responses. Set the active response variant to control what the endpoint returns.',
    addResponse: '+ Add Response',
    responseVariants: 'Response Variants',
    changeStatusCode: 'Change status code',
    customCode: 'Custom code (100-599)',
    descriptionLabel: 'Description',
    delay: 'Delay (s)',
    globalDefault: 'Global default: {0}s',
    noDelay: 'No delay',
    memo: 'Memo',
    memoPlaceholder: 'Notes about this response variant...',
    matchConditions: 'Match Conditions',
    addBody: 'Body',
    addHeader: 'Header',
    addQueryParam: 'Query Param',
    addPathParam: 'Path Param',
    noConditions: 'No conditions set \u2014 this variant acts as a fallback.\nAdd conditions to enable conditional matching.',
    combine: 'Combine:',
    bodyRules: 'Body Rules',
    headerRules: 'Header Rules',
    queryParamRules: 'Query Param Rules',
    pathParamRules: 'Path Param Rules',
    responseBody: 'Response Body',
    formatJson: 'Format JSON',
  },

  body: {
    title: 'Request Body',
    description: "Define the expected request body. This description is for documentation - it won't limit the requests this endpoint receives.",
    beautifyJson: 'Beautify JSON',
    contentType: 'Content-Type',
    key: 'Key',
    type: 'Type',
    value: 'Value',
    text: 'Text',
    file: 'File',
    addField: '+ Add Field',
  },

  headers: {
    title: 'Request Headers',
    description: "Define the expected request headers. This is for documentation only â€” the mock server will respond regardless of the headers sent.",
    header: 'Header',
    value: 'Value',
    addHeader: '+ Add Header',
  },

  params: {
    pathParameters: 'Path Parameters',
    pathParamsDesc: 'Automatically detected from the endpoint path. Incoming requests matching this pattern will be captured.',
    parameter: 'Parameter',
    pattern: 'Pattern',
    anyValue: '[any value]',
    queryParameters: 'Query Parameters',
    queryParamsDesc: 'Define accepted query parameter keys. The mock server matches by path only - any parameter values will receive the same response.',
    example: 'Example',
    addParam: '+ Add Param',
  },

  validation: {
    pathRequired: 'Path is required',
    nameRequired: 'Name is required',
  },

  operators: {
    equals: 'Equals',
    contains: 'Contains',
    startsWith: 'Starts with',
    endsWith: 'Ends with',
    regex: 'Regex',
  },

  onboarding: {
    featureGuide: 'Feature Guide',
    welcomeTo: 'Welcome to Mocka',
    buildMockApis: 'Build Mock APIs in Seconds',
    welcomeDescription: 'Mocka helps you create, manage, and serve mock API endpoints with dynamic responses, conditional logic, and environment variables \u2014 all from a beautiful interface.',
    dynamicTemplates: 'Dynamic Templates',
    dynamicTemplatesDesc: 'Use {{$randomUUID}}, {{$timestamp}} and 30+ built-in variables to generate dynamic response data on every request.',
    conditionalMatchRules: 'Conditional Match Rules',
    conditionalMatchRulesDesc: 'Define body and header conditions to automatically select the right response variant based on incoming request data.',
    environmentVariables: 'Environment Variables',
    environmentVariablesDesc: 'Create multiple environments with key-value variables. Switch between dev, staging, and production configs instantly.',
    requestContextHelpers: 'Request Context Helpers',
    requestContextHelpersDesc: "Echo back request data with {{$body 'field'}}, {{$headers 'key'}}, {{$queryParams 'q'}} and {{$pathParams 'id'}} helpers.",
    pathParameters: 'Path Parameters',
    pathParametersDesc: 'Support :param and {param} syntax for dynamic URL segments. Automatically matched and extracted from incoming requests.',
    importExportTitle: 'Import & Export',
    importExportDesc: 'Share mock configurations with your team. Export collections as JSON and import them into any Mocka instance seamlessly.',
    previewMatchConditions: 'MATCH CONDITIONS',
    previewBodyRules: 'BODY RULES',
    previewResponseBody: 'RESPONSE BODY',
    previewEndpointPath: 'ENDPOINT PATH',
    previewExportPreview: 'EXPORT PREVIEW',
    previewActive: 'Active',
    previewKey: 'KEY',
    previewValue: 'VALUE',
    previewImport: 'Import',
    previewExport: 'Export',
    previewBothSyntax: 'Both :param and {param} syntax supported',
  },
};

export type Translations = typeof en;
export default en;
